package HSEBank.finance.Application;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.interfaces.IBankAccountService;
import HSEBank.finance.Core.patterns.commands.CreateAccountCommand;
import HSEBank.finance.Core.patterns.commands.UpdateAccountCommand;
import HSEBank.finance.Core.patterns.decorator.TimingDecorator;
import HSEBank.finance.Core.services.BalanceService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class AccountManagementService {
    private final IBankAccountService accountService;
    private final CLIMenuService menuService;
    private final InputValidator inputValidator;
    private final BalanceService balanceService;

    public void createAccount() {
        try {
            String name = menuService.getInput("Enter account name: ");
            if (!inputValidator.isValidName(name)) {
                menuService.showError("Account name cannot be empty");
                return;
            }

            double balance = inputValidator.getValidatedDouble("Enter initial balance: ", 0.0, 1_000_000.0);

            var createCmd = new CreateAccountCommand(accountService, name, balance);

            String validationError = createCmd.validate();
            if (validationError != null) {
                menuService.showError(validationError);
                return;
            }

            new TimingDecorator(createCmd).execute();
            BankAccount account = createCmd.getCreatedAccount();
            menuService.showSuccess("Account created: " + account.getName() + " (ID: " + account.getId() + ")");

        } catch (IllegalArgumentException e) {
            menuService.showError("Validation error: " + e.getMessage());
        } catch (Exception e) {
            log.error("Account creation failed", e);
            menuService.showError("System error. Please try again.");
        }
    }

    public void showAllAccounts() {
        try {
            List<BankAccount> accounts = accountService.getAllAccounts();
            if (accounts.isEmpty()) {
                menuService.showMessage("üì≠ No accounts found");
                return;
            }

            menuService.showMessage("\nüìã ACCOUNTS LIST:");
            menuService.showMessage("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
            menuService.showMessage("‚îÇ ID                                 ‚îÇ Name               ‚îÇ Balance    ‚îÇ");
            menuService.showMessage("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");

            for (BankAccount account : accounts) {
                String line = String.format("‚îÇ %-34s ‚îÇ %-18s ‚îÇ %10.2f ‚îÇ",
                        account.getId(),
                        account.getName(),
                        account.getBalance());
                menuService.showMessage(line);
            }
            menuService.showMessage("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");

        } catch (Exception e) {
            log.error("Error loading accounts", e);
            menuService.showError("Failed to load accounts");
        }
    }

    public void findAccountById() {
        try {
            String id = inputValidator.getValidatedUUID("Enter account ID: ");
            BankAccount account = accountService.getAccount(UUID.fromString(id));

            menuService.showMessage("\nüîç ACCOUNT DETAILS:");
            menuService.showMessage("ID: " + account.getId());
            menuService.showMessage("Name: " + account.getName());
            menuService.showMessage("Balance: " + account.getBalance());

        } catch (Exception e) {
            menuService.showError("Account not found: " + e.getMessage());
        }
    }

    public void updateAccount() {
        try {
            String id = inputValidator.getValidatedUUID("Enter account ID to update: ");
            String name = menuService.getInput("Enter new account name: ");
            double balance = inputValidator.getValidatedDouble("Enter new balance: ", 0.0, 1_000_000.0);

            var updateCmd = new UpdateAccountCommand(accountService, UUID.fromString(id), name, balance);
            new TimingDecorator(updateCmd).execute();

            menuService.showSuccess("Account updated successfully");

        } catch (IllegalArgumentException e) {
            menuService.showError("Validation error: " + e.getMessage());
        } catch (Exception e) {
            log.error("Account update failed", e);
            menuService.showError("Failed to update account");
        }
    }

    public void deleteAccount() {
        try {
            String id = inputValidator.getValidatedUUID("Enter account ID to delete: ");
            accountService.deleteAccount(UUID.fromString(id));
            menuService.showSuccess("Account deleted successfully");

        } catch (IllegalArgumentException e) {
            menuService.showError("Account not found: " + e.getMessage());
        } catch (Exception e) {
            log.error("Account deletion failed", e);
            menuService.showError("Failed to delete account");
        }
    }

    public void recalculateAccountBalance() {
        try {
            String accountId = inputValidator.getValidatedUUID("Enter account ID to recalculate: ");
            double newBalance = balanceService.recalculateBalance(UUID.fromString(accountId));
            menuService.showSuccess("Balance recalculated: " + newBalance);
        } catch (Exception e) {
            menuService.showError(e.getMessage());
        }
    }
}package HSEBank.finance.Application;

import HSEBank.finance.Core.services.AnalyticsFacade;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;

@Component
@RequiredArgsConstructor
public class AnalyticsManager {
    private final CLIMenuService menuService;
    private final AnalyticsFacade analyticsFacade;

    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

    public void showAnalyticsMenu() {
        while (true) {
            showAnalyticsOptions();
            String choice = menuService.getInput("\nSelect option: ");

            switch (choice) {
                case "1" -> showBalanceDifference();
                case "2" -> showIncomesByCategory();
                case "3" -> showExpensesByCategory();
                case "4" -> showAnalyticsSummary();
                case "0" -> { return; }
                default -> menuService.showError("Invalid choice!");
            }
        }
    }

    private void showAnalyticsOptions() {
        menuService.showMessage("\n ANALYTICS & REPORTS:");
        menuService.showMessage("1. Balance Difference (Income - Expense)");
        menuService.showMessage("2. Incomes by Category");
        menuService.showMessage("3. Expenses by Category");
        menuService.showMessage("4. Analytics Summary");
        menuService.showMessage("0. Back");
    }

    private void showBalanceDifference() {
        try {
            LocalDateTime startDate = getDateInput("Enter start date (yyyy-MM-dd HH:mm): ");
            LocalDateTime endDate = getDateInput("Enter end date (yyyy-MM-dd HH:mm): ");

            double difference = analyticsFacade.calculateBalanceDifference(startDate, endDate);
            menuService.showMessage(String.format("\nüìä BALANCE DIFFERENCE: %.2f", difference));
            menuService.showMessage("Period: " + startDate.format(dateFormatter) + " - " + endDate.format(dateFormatter));

        } catch (Exception e) {
            menuService.showError(e.getMessage());
        }
    }

    private void showIncomesByCategory() {
        try {
            LocalDateTime startDate = getDateInput("Enter start date (yyyy-MM-dd HH:mm): ");
            LocalDateTime endDate = getDateInput("Enter end date (yyyy-MM-dd HH:mm): ");

            var incomesByCategory = analyticsFacade.groupIncomesByCategory(startDate, endDate);
            menuService.showMessage("\n INCOMES BY CATEGORY:");
            incomesByCategory.forEach((category, amount) ->
                    menuService.showMessage(String.format("  %s: %.2f", category, amount)));

        } catch (Exception e) {
            menuService.showError(e.getMessage());
        }
    }

    private void showExpensesByCategory() {
        try {
            LocalDateTime startDate = getDateInput("Enter start date (yyyy-MM-dd HH:mm): ");
            LocalDateTime endDate = getDateInput("Enter end date (yyyy-MM-dd HH:mm): ");

            var expensesByCategory = analyticsFacade.groupExpensesByCategory(startDate, endDate);
            menuService.showMessage("\n EXPENSES BY CATEGORY:");
            expensesByCategory.forEach((category, amount) ->
                    menuService.showMessage(String.format("  %s: %.2f", category, amount)));

        } catch (Exception e) {
            menuService.showError(e.getMessage());
        }
    }

    private void showAnalyticsSummary() {
        try {
            LocalDateTime startDate = getDateInput("Enter start date (yyyy-MM-dd HH:mm): ");
            LocalDateTime endDate = getDateInput("Enter end date (yyyy-MM-dd HH:mm): ");

            var summary = analyticsFacade.getAnalyticsSummary(startDate, endDate);
            menuService.showMessage("\n ANALYTICS SUMMARY:");
            menuService.showMessage(String.format("Total Income: %.2f", summary.totalIncome));
            menuService.showMessage(String.format("Total Expense: %.2f", summary.totalExpense));
            menuService.showMessage(String.format("Balance Difference: %.2f", summary.totalIncome - summary.totalExpense));
            menuService.showMessage("Operations Count: " + summary.operationCount);
            menuService.showMessage(String.format("Average Income: %.2f", summary.averageIncome));
            menuService.showMessage(String.format("Average Expense: %.2f", summary.averageExpense));

        } catch (Exception e) {
            menuService.showError(e.getMessage());
        }
    }

    private LocalDateTime getDateInput(String prompt) {
        while (true) {
            try {
                String dateInput = menuService.getInput(prompt);
                return LocalDateTime.parse(dateInput, dateFormatter);
            } catch (DateTimeParseException e) {
                menuService.showError("Invalid date format. Please use yyyy-MM-dd HH:mm");
            }
        }
    }
}package HSEBank.finance.Application;

import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.ICategoryService;
import HSEBank.finance.Core.patterns.commands.UpdateCategoryCommand;
import HSEBank.finance.Core.patterns.decorator.TimingDecorator;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class CategoryManager {
    private final ICategoryService categoryService;
    private final CLIMenuService menuService;
    private final InputValidator inputValidator;

    public void createCategory() {
        try {
            OperationType type = inputValidator.getValidatedOperationType("Select category type:");
            String name = menuService.getInput("Enter category name: ");

            Category category = categoryService.createCategory(type, name);
            menuService.showSuccess("Category created: " + category.getName() + " (ID: " + category.getId() + ")");

        } catch (Exception e) {
            menuService.showError("Category creation failed: " + e.getMessage());
        }
    }

    public void showAllCategories() {
        try {
            List<Category> categories = categoryService.getAllCategories();
            if (categories.isEmpty()) {
                menuService.showMessage(" No categories found");
                return;
            }

            menuService.showMessage("\n CATEGORIES LIST:");
            menuService.showMessage("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
            menuService.showMessage("‚îÇ ID                                 ‚îÇ Type       ‚îÇ Name               ‚îÇ");
            menuService.showMessage("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");

            for (Category category : categories) {
                String typeEmoji = category.getOperationType() == OperationType.INCOME ? "üí∞" : "üí∏";
                String line = String.format("‚îÇ %-34s ‚îÇ %-4s%-6s ‚îÇ %-18s ‚îÇ",
                        category.getId(),
                        typeEmoji,
                        category.getOperationType(),
                        category.getName());
                menuService.showMessage(line);
            }
            menuService.showMessage("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");

        } catch (Exception e) {
            menuService.showError("Failed to load categories: " + e.getMessage());
        }
    }

    public void findCategoryById() {
        try {
            String id = inputValidator.getValidatedUUID("Enter category ID: ");
            Category category = categoryService.getCategory(UUID.fromString(id));

            menuService.showMessage("\n CATEGORY DETAILS:");
            menuService.showMessage("ID: " + category.getId());
            menuService.showMessage("Type: " + category.getOperationType());
            menuService.showMessage("Name: " + category.getName());

        } catch (Exception e) {
            menuService.showError("Category not found: " + e.getMessage());
        }
    }

    public void updateCategory() {
        try {
            String id = inputValidator.getValidatedUUID("Enter category ID to update: ");
            OperationType type = inputValidator.getValidatedOperationType("Select new category type:");
            String name = menuService.getInput("Enter new category name: ");

            var updateCmd = new UpdateCategoryCommand(categoryService, UUID.fromString(id), type, name);
            new TimingDecorator(updateCmd).execute();

            menuService.showSuccess("Category updated successfully");

        } catch (Exception e) {
            menuService.showError("Category update failed: " + e.getMessage());
        }
    }

    public void deleteCategory() {
        try {
            String id = inputValidator.getValidatedUUID("Enter category ID to delete: ");
            categoryService.deleteCategory(UUID.fromString(id));
            menuService.showSuccess("Category deleted successfully");

        } catch (Exception e) {
            menuService.showError("Category deletion failed: " + e.getMessage());
        }
    }
}package HSEBank.finance.Application;

import org.springframework.stereotype.Service;
import java.util.Scanner;

@Service
public class CLIMenuService {
    private final Scanner scanner = new Scanner(System.in);

    public void showWelcomeMessage() {
        System.out.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë           HSEBank Finance CLI        ‚ïë");
        System.out.println("‚ïë      Financial Management System     ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        System.out.println();
    }

    public String showMainMenu() {
        System.out.println("\n MAIN MENU:");
        System.out.println("1. Account Management");
        System.out.println("2. Category Management");
        System.out.println("3. Operation Management");
        System.out.println("4. Analytics & Reports");
        System.out.println("5. Data Export");
        System.out.println("6. Data Import");
        System.out.println("7. System Tools");
        System.out.println("8. Pattern Demonstrations");
        System.out.println("0. Exit");
        System.out.print("\nSelect option: ");
        return scanner.nextLine();
    }

    public String showAccountManagementMenu() {
        System.out.println("\n ACCOUNT MANAGEMENT:");
        System.out.println("1. Create Account");
        System.out.println("2. List All Accounts");
        System.out.println("3. Find Account by ID");
        System.out.println("4. Update Account");
        System.out.println("5. Delete Account");
        System.out.println("6. Recalculate Balance");
        System.out.println("0. Back");
        System.out.print("\nSelect option: ");
        return scanner.nextLine();
    }

    public String showSystemToolsMenu() {
        System.out.println("\n SYSTEM TOOLS:");
        System.out.println("1. Recalculate All Balances");
        System.out.println("2. Cache Statistics");
        System.out.println("3. Clear Cache");
        System.out.println("0. Back");
        System.out.print("\nSelect option: ");
        return scanner.nextLine();
    }

    public String showImportMenu() {
        System.out.println("\n DATA IMPORT:");
        System.out.println("1. Import from JSON");
        System.out.println("2. Import from CSV");
        System.out.println("3. Import from YAML");
        System.out.println("0. Back");
        System.out.print("\nSelect option: ");
        return scanner.nextLine();
    }

    public String getInput(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine();
    }

    public void showMessage(String message) {
        System.out.println(message);
    }

    public void showError(String error) {
        System.out.println(" Error: " + error);
    }

    public void showSuccess(String message) {
        System.out.println("Success: " + message);
    }
}package HSEBank.finance.Application;

import HSEBank.finance.Core.patterns.commands.ExportDataCommand;
import HSEBank.finance.Core.patterns.decorator.TimingDecorator;
import HSEBank.finance.Core.services.ExportService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
@RequiredArgsConstructor
public class ExportManager {
    private final CLIMenuService menuService;
    private final ExportService exportService;

    public void showExportMenu() {
        while (true) {
            showExportOptions();
            String choice = menuService.getInput("\nSelect option: ");

            switch (choice) {
                case "1" -> exportData("json");
                case "2" -> exportData("csv");
                case "3" -> exportData("yaml");
                case "0" -> { return; }
                default -> menuService.showError("Invalid choice!");
            }
        }
    }

    private void showExportOptions() {
        menuService.showMessage("\n DATA EXPORT:");
        menuService.showMessage("1. Export to JSON");
        menuService.showMessage("2. Export to CSV");
        menuService.showMessage("3. Export to YAML");
        menuService.showMessage("0. Back");
    }

    private void exportData(String format) {
        try {
            String accountIdInput = menuService.getInput("Enter account ID (or press Enter for all accounts): ");
            UUID accountId = accountIdInput.isEmpty() ? null : UUID.fromString(accountIdInput);

            String fileName = "exported_data." + format;
            var exportCommand = new ExportDataCommand(exportService, format, fileName, accountId);
            new TimingDecorator(exportCommand).execute();

            menuService.showSuccess("Data exported successfully to: " + fileName);

        } catch (Exception e) {
            menuService.showError(e.getMessage());
        }
    }
}package HSEBank.finance.Application;

import lombok.RequiredArgsConstructor;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class FinanceCLI implements CommandLineRunner {

    private final CLIMenuService menuService;
    private final AccountManagementService accountManagementService;
    private final CategoryManager categoryManagementService;
    private final OperationManager operationManager;
    private final AnalyticsManager analyticsManager;
    private final ExportManager exportManager;
    private final ImportManager importManager;
    private final SystemToolsManager systemToolsManager;
    private final PatternDemoManager patternDemoManager;

    @Override
    public void run(String... args) {
        menuService.showWelcomeMessage();
        mainMenu();
    }

    private void mainMenu() {
        while (true) {
            String choice = menuService.showMainMenu();

            switch (choice) {
                case "1" -> accountManagement();
                case "2" -> categoryManagement();
                case "3" -> operationManagement();
                case "4" -> analyticsManager.showAnalyticsMenu();
                case "5" -> exportManager.showExportMenu();
                case "6" -> importManager.showImportMenu();
                case "7" -> systemToolsManager.showSystemToolsMenu();
                case "8" -> patternDemoManager.demonstratePatterns();
                case "0" -> {
                    menuService.showMessage("\nüëã Goodbye!");
                    return;
                }
                default -> menuService.showError("Invalid choice!");
            }
        }
    }

    private void accountManagement() {
        while (true) {
            String choice = menuService.showAccountManagementMenu();

            switch (choice) {
                case "1" -> accountManagementService.createAccount();
                case "2" -> accountManagementService.showAllAccounts();
                case "3" -> accountManagementService.findAccountById();
                case "4" -> accountManagementService.updateAccount();
                case "5" -> accountManagementService.deleteAccount();
                case "6" -> accountManagementService.recalculateAccountBalance();
                case "0" -> { return; }
                default -> menuService.showError("Invalid choice!");
            }
        }
    }

    private void categoryManagement() {
        while (true) {
            menuService.showMessage("\nüìÅ CATEGORY MANAGEMENT:");
            menuService.showMessage("1. üìù Create Category");
            menuService.showMessage("2. üìã List All Categories");
            menuService.showMessage("3. üîç Find Category by ID");
            menuService.showMessage("4. ‚úèÔ∏è Update Category");
            menuService.showMessage("5. üóëÔ∏è Delete Category");
            menuService.showMessage("0. ‚Ü©Ô∏è Back");

            String choice = menuService.getInput("\nSelect option: ");

            switch (choice) {
                case "1" -> categoryManagementService.createCategory();
                case "2" -> categoryManagementService.showAllCategories();
                case "3" -> categoryManagementService.findCategoryById();
                case "4" -> categoryManagementService.updateCategory();
                case "5" -> categoryManagementService.deleteCategory();
                case "0" -> { return; }
                default -> menuService.showError("Invalid choice!");
            }
        }
    }

    private void operationManagement() {
        while (true) {
            menuService.showMessage("\nüí∞ OPERATION MANAGEMENT:");
            menuService.showMessage("1. üìù Create Operation");
            menuService.showMessage("2. üìã List All Operations");
            menuService.showMessage("3. üîç Find Operation by ID");
            menuService.showMessage("4. ‚úèÔ∏è Update Operation");
            menuService.showMessage("5. üóëÔ∏è Delete Operation");
            menuService.showMessage("0. ‚Ü©Ô∏è Back");

            String choice = menuService.getInput("\nSelect option: ");

            switch (choice) {
                case "1" -> operationManager.createOperation();
                case "2" -> operationManager.showAllOperations();
                case "3" -> operationManager.findOperationById();
                case "4" -> operationManager.updateOperation();
                case "5" -> operationManager.deleteOperation();
                case "0" -> { return; }
                default -> menuService.showError("Invalid choice!");
            }
        }
    }
}package HSEBank.finance.Application;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@SpringBootApplication(scanBasePackages = "HSEBank.finance")
public class FinanceSpringApp {

    public static void main(String[] args) {
        try {
            log.info("Starting HSEBank Finance Application...");
            SpringApplication.run(FinanceSpringApp.class, args);
            log.info("HSEBank Finance Application started successfully");
        } catch (Exception e) {
            log.error("Failed to start application", e);
            System.exit(1);
        }
    }
}package HSEBank.finance.Application;

import HSEBank.finance.Core.services.DataImportService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class ImportManager {
    private final CLIMenuService menuService;
    private final DataImportService importService;

    public void showImportMenu() {
        while (true) {
            String choice = menuService.showImportMenu();

            switch (choice) {
                case "1" -> importData("json");
                case "2" -> importData("csv");
                case "3" -> importData("yaml");
                case "0" -> { return; }
                default -> menuService.showError("Invalid choice!");
            }
        }
    }

    private void importData(String format) {
        try {
            String filePath = menuService.getInput("Enter file path: ");
            String result = importService.importData(format, filePath);
            menuService.showSuccess(result);
        } catch (Exception e) {
            menuService.showError(e.getMessage());
        }
    }
}package HSEBank.finance.Application;

import HSEBank.finance.Core.domain.enums.OperationType;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class InputValidator {
    private final CLIMenuService menuService;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

    public double getValidatedDouble(String prompt, double min, double max) {
        while (true) {
            try {
                String input = menuService.getInput(prompt);
                double value = Double.parseDouble(input);

                if (value < min) {
                    menuService.showError("Value must be at least " + min);
                    continue;
                }
                if (value > max) {
                    menuService.showError("Value must be at most " + max);
                    continue;
                }
                return value;
            } catch (NumberFormatException e) {
                menuService.showError("Please enter a valid number");
            }
        }
    }

    public String getValidatedUUID(String prompt) {
        while (true) {
            try {
                String input = menuService.getInput(prompt);
                UUID.fromString(input);
                return input;
            } catch (IllegalArgumentException e) {
                menuService.showError("Please enter a valid UUID format");
            }
        }
    }

    public boolean isValidName(String name) {
        return name != null && !name.trim().isEmpty();
    }

    public LocalDateTime getValidatedDateTime(String prompt) {
        while (true) {
            try {
                String input = menuService.getInput(prompt);
                return LocalDateTime.parse(input, dateFormatter);
            } catch (DateTimeParseException e) {
                menuService.showError("Invalid date format. Please use yyyy-MM-dd HH:mm");
            }
        }
    }

    public OperationType getValidatedOperationType(String prompt) {
        while (true) {
            try {
                menuService.showMessage(prompt);
                menuService.showMessage("1. Income");
                menuService.showMessage("2. Expense");
                String choice = menuService.getInput("Choice: ");

                return switch (choice) {
                    case "1" -> OperationType.INCOME;
                    case "2" -> OperationType.EXPENSE;
                    default -> throw new IllegalArgumentException("Invalid choice");
                };
            } catch (IllegalArgumentException e) {
                menuService.showError("Please select 1 for Income or 2 for Expense");
            }
        }
    }
}package HSEBank.finance.Application;

import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IOperationService;
import HSEBank.finance.Core.patterns.commands.AddOperationCommand;
import HSEBank.finance.Core.patterns.commands.DeleteOperationCommand;
import HSEBank.finance.Core.patterns.commands.UpdateOperationCommand;
import HSEBank.finance.Core.patterns.decorator.TimingDecorator;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class OperationManager {
    private final IOperationService operationService;
    private final CLIMenuService menuService;
    private final InputValidator inputValidator;

    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

    public void createOperation() {
        try {
            OperationType type = inputValidator.getValidatedOperationType("Select operation type:");
            String accountId = inputValidator.getValidatedUUID("Enter account ID: ");
            double amount = inputValidator.getValidatedDouble("Enter amount: ", 0.01, 1_000_000.0);
            String categoryId = inputValidator.getValidatedUUID("Enter category ID: ");
            String description = menuService.getInput("Enter description: ");

            LocalDateTime date = LocalDateTime.now();

            var addOpCmd = new AddOperationCommand(type, operationService, UUID.fromString(accountId),
                    amount, date, UUID.fromString(categoryId), description);
            new TimingDecorator(addOpCmd).execute();

            Operation operation = addOpCmd.getOperation();
            menuService.showSuccess("Operation created: " + operation.getId());

        } catch (Exception e) {
            menuService.showError("Operation creation failed: " + e.getMessage());
        }
    }

    public void showAllOperations() {
        try {
            List<Operation> operations = operationService.getAllOperations();
            if (operations.isEmpty()) {
                menuService.showMessage(" No operations found");
                return;
            }

            menuService.showMessage("\n OPERATIONS LIST:");
            menuService.showMessage("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
            menuService.showMessage("‚îÇ ID                                 ‚îÇ Type       ‚îÇ Account ID         ‚îÇ Amount     ‚îÇ Date               ‚îÇ");
            menuService.showMessage("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");

            for (Operation operation : operations) {
                String typeEmoji = operation.getType() == OperationType.INCOME ? "üí∞" : "üí∏";
                String line = String.format("‚îÇ %-34s ‚îÇ %-4s%-6s ‚îÇ %-18s ‚îÇ %10.2f ‚îÇ %-18s ‚îÇ",
                        operation.getId(),
                        typeEmoji,
                        operation.getType(),
                        operation.getBankAccountId(),
                        operation.getAmount(),
                        operation.getDate().format(dateFormatter));
                menuService.showMessage(line);
            }
            menuService.showMessage("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");

        } catch (Exception e) {
            menuService.showError("Failed to load operations: " + e.getMessage());
        }
    }

    public void findOperationById() {
        try {
            String id = inputValidator.getValidatedUUID("Enter operation ID: ");
            Operation operation = operationService.getOperation(UUID.fromString(id));

            menuService.showMessage("\n OPERATION DETAILS:");
            menuService.showMessage("ID: " + operation.getId());
            menuService.showMessage("Type: " + operation.getType());
            menuService.showMessage("Account ID: " + operation.getBankAccountId());
            menuService.showMessage("Amount: " + operation.getAmount());
            menuService.showMessage("Date: " + operation.getDate());
            menuService.showMessage("Category ID: " + operation.getCategoryId());
            menuService.showMessage("Description: " + operation.getDescription());

        } catch (Exception e) {
            menuService.showError("Operation not found: " + e.getMessage());
        }
    }

    public void updateOperation() {
        try {
            String id = inputValidator.getValidatedUUID("Enter operation ID to update: ");
            OperationType type = inputValidator.getValidatedOperationType("Select new operation type:");
            String accountId = inputValidator.getValidatedUUID("Enter new account ID: ");
            double amount = inputValidator.getValidatedDouble("Enter new amount: ", 0.01, 1_000_000.0);
            String categoryId = inputValidator.getValidatedUUID("Enter new category ID: ");
            String description = menuService.getInput("Enter new description: ");

            LocalDateTime date = LocalDateTime.now();

            var updateOpCmd = new UpdateOperationCommand(operationService, UUID.fromString(id), type,
                    UUID.fromString(accountId), amount, date, UUID.fromString(categoryId), description);
            new TimingDecorator(updateOpCmd).execute();

            menuService.showSuccess("Operation updated successfully");

        } catch (Exception e) {
            menuService.showError("Operation update failed: " + e.getMessage());
        }
    }

    public void deleteOperation() {
        try {
            String id = inputValidator.getValidatedUUID("Enter operation ID to delete: ");
            var deleteOpCmd = new DeleteOperationCommand(operationService, UUID.fromString(id));
            new TimingDecorator(deleteOpCmd).execute();

            menuService.showSuccess("Operation deleted successfully");

        } catch (Exception e) {
            menuService.showError("Operation deletion failed: " + e.getMessage());
        }
    }
}package HSEBank.finance.Application;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IBankAccountService;
import HSEBank.finance.Core.domain.interfaces.ICategoryService;
import HSEBank.finance.Core.domain.interfaces.IOperationService;
import HSEBank.finance.Core.patterns.commands.CreateAccountCommand;
import HSEBank.finance.Core.patterns.commands.UpdateAccountCommand;
import HSEBank.finance.Core.patterns.commands.UpdateCategoryCommand;
import HSEBank.finance.Core.patterns.decorator.TimingDecorator;
import HSEBank.finance.Core.services.AnalyticsFacade;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@RequiredArgsConstructor
public class PatternDemoManager {
    private final CLIMenuService menuService;
    private final IBankAccountService accountService;
    private final ICategoryService categoryService;
    private final IOperationService operationService;
    private final AnalyticsFacade analyticsFacade;

    public void demonstratePatterns() {
        menuService.showMessage("\nüéØ PATTERN DEMONSTRATIONS:");
        menuService.showMessage("1. Command Pattern Demo");
        menuService.showMessage("2. Decorator Pattern Demo");
        menuService.showMessage("3. Full System Demo");

        String choice = menuService.getInput("\nSelect demo: ");

        switch (choice) {
            case "1" -> demonstrateCommands();
            case "2" -> demonstrateDecorator();
            case "3" -> runFullDemo();
            default -> menuService.showError("Invalid choice!");
        }
    }

    private void demonstrateCommands() {
        menuService.showMessage("\n‚ö° COMMAND PATTERN DEMO");

        // Create account using command
        var createCmd = new CreateAccountCommand(accountService, "Command Demo Account", 1000.0);
        new TimingDecorator(createCmd).execute();

        BankAccount account = createCmd.getCreatedAccount();
        menuService.showMessage("‚úÖ Created account: " + account.getName());

        // Update account using command
        var updateCmd = new UpdateAccountCommand(accountService, account.getId(), "Updated Demo Account", 1500.0);
        new TimingDecorator(updateCmd).execute();
        menuService.showMessage("‚úÖ Updated account balance: " + updateCmd.getUpdatedAccount().getBalance());
    }

    private void demonstrateDecorator() {
        menuService.showMessage("\nüé≠ DECORATOR PATTERN DEMO");

        // Create a category first for the demo
        Category demoCategory = categoryService.createCategory(OperationType.EXPENSE, "Demo Category");

        // Update category with timing
        var updateCatCmd = new UpdateCategoryCommand(categoryService, demoCategory.getId(),
                OperationType.EXPENSE, "Updated Demo Category");
        var timedCommand = new TimingDecorator(updateCatCmd);

        menuService.showMessage("Executing timed command...");
        timedCommand.execute();

        // Clean up
        categoryService.deleteCategory(demoCategory.getId());
    }

    private void runFullDemo() {
        menuService.showMessage("\nüöÄ FULL SYSTEM DEMO");

        // Create demo data
        BankAccount demoAccount = accountService.createAccount("Demo Account", 5000.0);
        Category incomeCategory = categoryService.createCategory(OperationType.INCOME, "Demo Income");
        Category expenseCategory = categoryService.createCategory(OperationType.EXPENSE, "Demo Expense");

        // Add operations
        operationService.addOperation(OperationType.INCOME, demoAccount.getId(), 1000.0,
                LocalDateTime.now(), incomeCategory.getId(), "Salary");
        operationService.addOperation(OperationType.EXPENSE, demoAccount.getId(), 500.0,
                LocalDateTime.now(), expenseCategory.getId(), "Shopping");

        menuService.showSuccess("Demo data created successfully!");
        menuService.showMessage("Account: " + demoAccount.getName());
        menuService.showMessage("Categories: " + incomeCategory.getName() + ", " + expenseCategory.getName());

        // Show analytics
        var summary = analyticsFacade.getAnalyticsSummary(
                LocalDateTime.now().minusDays(1),
                LocalDateTime.now().plusDays(1)
        );
        menuService.showMessage("Demo Analytics - Balance Difference: " + (summary.totalIncome - summary.totalExpense));
    }
}package HSEBank.finance.Application;

import HSEBank.finance.Core.services.BalanceService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class SystemToolsManager {
    private final CLIMenuService menuService;
    private final BalanceService balanceService;

    public void showSystemToolsMenu() {
        while (true) {
            String choice = menuService.showSystemToolsMenu();

            switch (choice) {
                case "1" -> recalculateAllBalances();
                case "2" -> showCacheStatistics();
                case "3" -> clearCache();
                case "0" -> { return; }
                default -> menuService.showError("Invalid choice!");
            }
        }
    }

    private void recalculateAllBalances() {
        try {
            var result = balanceService.recalculateAllBalances();
            menuService.showSuccess(String.format(
                    "Recalculation complete: %d accounts processed, %d corrected, total correction: %.2f",
                    result.totalAccounts, result.correctedAccounts, result.totalCorrection
            ));
        } catch (Exception e) {
            menuService.showError(e.getMessage());
        }
    }

    private void showCacheStatistics() {
        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫—ç—à–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–∑–∂–µ
        menuService.showMessage("\n CACHE STATISTICS:");
        menuService.showMessage("Cache statistics feature coming soon...");
    }

    private void clearCache() {
        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–∑–∂–µ
        menuService.showSuccess("Cache clearing feature coming soon...");
    }
}package HSEBank.finance.Core.domain.entities;

import HSEBank.finance.Core.domain.interfaces.FinancialVisitor;
import HSEBank.finance.Core.domain.interfaces.IEntity;
import java.util.UUID;
import lombok.Getter;

@Getter
public class BankAccount implements IEntity {
    private final UUID id;
    private String name;
    private double balance;

    public BankAccount(UUID id, String name, double balance) {
        this.id = id;
        this.name = name;
        this.balance = balance;
    }

    public void update(String name, double balance) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Account name cannot be empty");
        }
        if (balance < 0) {
            throw new IllegalArgumentException("Balance cannot be negative");
        }
        this.name = name;
        this.balance = balance;
    }

    public void accept(FinancialVisitor visitor) {
        visitor.visit(this);
    }

    public void deposit(double amount) {
        if (amount <= 0) throw new IllegalArgumentException("Deposit amount must be positive");
        this.balance += amount;
    }

    public void withdraw(double amount) {
        if (amount <= 0) throw new IllegalArgumentException("Withdrawal amount must be positive");
        if (amount > balance) throw new IllegalArgumentException("Insufficient funds");
        this.balance -= amount;
    }
}package HSEBank.finance.Core.domain.entities;

import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.FinancialVisitor;
import HSEBank.finance.Core.domain.interfaces.IEntity;
import java.util.UUID;
import lombok.Getter;

@Getter
public class Category implements IEntity {
    private final UUID id;
    private OperationType operationType;
    private String name;

    public Category(UUID id, OperationType operationType, String name) {
        this.id = id;
        this.operationType = operationType;
        this.name = name;
    }

    public void update(OperationType operationType, String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Category name cannot be empty");
        }
        this.operationType = operationType;
        this.name = name;
    }

    public void accept(FinancialVisitor visitor) {
        visitor.visit(this);
    }
}package HSEBank.finance.Core.domain.entities;

import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.FinancialVisitor;
import HSEBank.finance.Core.domain.interfaces.IEntity;
import java.time.LocalDateTime;
import java.util.UUID;
import lombok.Getter;

@Getter
public class Operation implements IEntity {
    private final UUID id;
    private OperationType type;
    private UUID bankAccountId;
    private double amount;
    private LocalDateTime date;
    private UUID categoryId;
    private String description;

    public Operation(UUID id, OperationType type, UUID bankAccountId,
                     double amount, LocalDateTime date, UUID categoryId, String description) {
        if (amount <= 0) throw new IllegalArgumentException("Amount must be positive");
        this.id = id;
        this.type = type;
        this.bankAccountId = bankAccountId;
        this.amount = amount;
        this.date = date;
        this.categoryId = categoryId;
        this.description = description;
    }

    public void update(OperationType type, UUID bankAccountId, double amount,
                       LocalDateTime date, UUID categoryId, String description) {
        if (amount <= 0) throw new IllegalArgumentException("Amount must be positive");
        this.type = type;
        this.bankAccountId = bankAccountId;
        this.amount = amount;
        this.date = date;
        this.categoryId = categoryId;
        this.description = description;
    }

    public void accept(FinancialVisitor visitor) {
        visitor.visit(this);
    }
}package HSEBank.finance.Core.domain.enums;


public enum OperationType {
    INCOME,
    EXPENSE
}package HSEBank.finance.Core.domain.interfaces;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;

import java.util.List;
import java.util.UUID;

public interface DataProvider {
    List<BankAccount> getAccounts(UUID accountId);
    List<Category> getAllCategories();
    List<Operation> getOperations(UUID accountId);
}package HSEBank.finance.Core.domain.interfaces;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;

public interface FinancialVisitor {
    void visit(BankAccount account);
    void visit(Category category);
    void visit(Operation operation);
}package HSEBank.finance.Core.domain.interfaces;

import HSEBank.finance.Core.domain.entities.BankAccount;

import java.util.List;
import java.util.UUID;

public interface IBankAccountService {
    BankAccount createAccount(String name, double initialBalance);
    BankAccount getAccount(UUID id);
    BankAccount updateAccount(UUID id, String name, double balance);
    void deleteAccount(UUID id);
    List<BankAccount> getAllAccounts();
    boolean accountExists(UUID id);
}
package HSEBank.finance.Core.domain.interfaces;

import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.enums.OperationType;

import java.util.List;
import java.util.UUID;

public interface ICategoryService {
    Category createCategory(OperationType type, String name);
    Category getCategory(UUID id);
    Category updateCategory(UUID id, OperationType type, String name);
    void deleteCategory(UUID id);
    List<Category> getAllCategories();
    List<Category> getCategoriesByType(OperationType type);
    boolean categoryExists(UUID id);
}package HSEBank.finance.Core.domain.interfaces;

public interface ICommand {
    void execute();
    void undo();
    String getDescription();
}package HSEBank.finance.Core.domain.interfaces;

import java.util.UUID;

public interface IEntity {
    UUID getId();
}
package HSEBank.finance.Core.domain.interfaces;

public interface IFinancialCommand extends ICommand {
    boolean canExecute();
    String validate();
}package HSEBank.finance.Core.domain.interfaces;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import java.time.LocalDateTime;
import java.util.UUID;

public interface IFinancialFactory {
    BankAccount createBankAccount(String name, double initialBalance);
    Category createCategory(OperationType type, String name);
    Operation createOperation(OperationType type, UUID bankAccountId, double amount, LocalDateTime date, UUID categoryId, String description);
}
package HSEBank.finance.Core.domain.interfaces;

import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

public interface IOperationService {
    Operation addOperation(OperationType type, UUID bankAccountId, double amount,
                           LocalDateTime date, UUID categoryId, String description);
    Operation getOperation(UUID id);
    Operation updateOperation(UUID id, OperationType type, UUID bankAccountId, double amount,
                              LocalDateTime date, UUID categoryId, String description);
    void deleteOperation(UUID id);
    List<Operation> getAllOperations();
    List<Operation> getOperationsByAccount(UUID accountId);
    List<Operation> getOperationsInPeriod(LocalDateTime startDate, LocalDateTime endDate);
}package HSEBank.finance.Core.domain.interfaces;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface IRepository<T extends IEntity> {
    T save(T entity);
    Optional<T> findById(UUID id);
    List<T> findAll();
    void delete(UUID id);
    boolean exists(UUID id);
}
package HSEBank.finance.Core.domain.interfaces;

public interface StructuredFinancialVisitor extends FinancialVisitor {
    void startArray(String arrayName);
    void endArray();
    String getResult();
    void reset();
}package HSEBank.finance.Core.patterns.commands;

import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IOperationService;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.UUID;

@Getter
public class AddOperationCommand extends BaseCommand {
    private final OperationType type;
    private final IOperationService operationService;
    private final UUID bankAccountId;
    private final double amount;
    private final LocalDateTime date;
    private final UUID categoryId;
    private final String description;
    private Operation operation;
    private UUID operationId;

    public AddOperationCommand(OperationType type, IOperationService operationService, UUID bankAccountId, double amount,
                               LocalDateTime date, UUID categoryId, String description) {
        super("Add operation for account: " + bankAccountId);
        this.type = type;
        this.operationService = operationService;
        this.bankAccountId = bankAccountId;
        this.amount = amount;
        this.date = date;
        this.categoryId = categoryId;
        this.description = description;
    }

    @Override
    public String validate() {
        if (bankAccountId == null) {
            return "Bank account ID cannot be null";
        }
        if (amount <= 0) {
            return "Amount must be positive";
        }
        if (categoryId == null) {
            return "Category ID cannot be null";
        }
        if (date == null) {
            return "Date cannot be null";
        }
        return null;
    }

    @Override
    public void execute() {
        operation = operationService.addOperation(type, bankAccountId, amount, date, categoryId, description);
        operationId = operation.getId();
    }

    @Override
    public void undo() {
        if (operationId != null) {
            operationService.deleteOperation(operationId);
        }
    }
}package HSEBank.finance.Core.patterns.commands;

import HSEBank.finance.Core.domain.interfaces.IFinancialCommand;

public abstract class BaseCommand implements IFinancialCommand {
    protected String description;

    public BaseCommand(String description) {
        this.description = description;
    }

    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public boolean canExecute() {
        return validate() == null;
    }

    @Override
    public String validate() {
        return null; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–æ—Ö–æ–¥–∏—Ç
    }

    @Override
    public void undo() {
        // –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è - –º–æ–∂–Ω–æ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å
    }
}package HSEBank.finance.Core.patterns.commands;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.interfaces.IBankAccountService;
import lombok.Getter;

import java.util.UUID;

@Getter
public class CreateAccountCommand extends BaseCommand {
    private final IBankAccountService accountService;
    private final String accountName;
    private final double initialBalance;
    private BankAccount createdAccount;
    private UUID createdAccountId;

    public CreateAccountCommand(IBankAccountService accountService, String accountName, double initialBalance) {
        super("Create bank account: " + accountName);
        this.accountService = accountService;
        this.accountName = accountName;
        this.initialBalance = initialBalance;
    }

    @Override
    public String validate() {
        if (accountName == null || accountName.trim().isEmpty()) {
            return "Account name cannot be empty";
        }
        if (initialBalance < 0) {
            return "Initial balance cannot be negative";
        }
        return null;
    }

    @Override
    public void execute() {
        createdAccount = accountService.createAccount(accountName, initialBalance);
        createdAccountId = createdAccount.getId();
    }

    @Override
    public void undo() {
        if (createdAccountId != null) {
            accountService.deleteAccount(createdAccountId);
        }
    }
}package HSEBank.finance.Core.patterns.commands;

import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.IOperationService;
import lombok.Getter;

import java.util.UUID;

@Getter
public class DeleteOperationCommand extends BaseCommand {
    private final IOperationService operationService;
    private final UUID operationId;
    private Operation deletedOperation;

    public DeleteOperationCommand(IOperationService operationService, UUID operationId) {
        super("Delete operation: " + operationId);
        this.operationService = operationService;
        this.operationId = operationId;
    }

    @Override
    public void execute() {
        deletedOperation = operationService.getOperation(operationId);
        operationService.deleteOperation(operationId);
    }

    @Override
    public void undo() {
        if (deletedOperation != null) {
            operationService.addOperation(
                    deletedOperation.getType(),
                    deletedOperation.getBankAccountId(),
                    deletedOperation.getAmount(),
                    deletedOperation.getDate(),
                    deletedOperation.getCategoryId(),
                    deletedOperation.getDescription()
            );
        }
    }
}package HSEBank.finance.Core.patterns.commands;

import HSEBank.finance.Core.domain.interfaces.ICommand;
import HSEBank.finance.Core.services.ExportService;
import java.util.UUID;

public class ExportDataCommand implements ICommand {
    private final ExportService exportService;
    private final String format;
    private final String filePath;
    private final UUID accountId;

    public ExportDataCommand(ExportService exportService, String format, String filePath, UUID accountId) {
        this.exportService = exportService;
        this.format = format;
        this.filePath = filePath;
        this.accountId = accountId;
    }

    @Override
    public void execute() {
        exportService.exportData(format, filePath, accountId);
    }

    @Override
    public void undo() {

    }

    @Override
    public String getDescription() {
        return "Export data to " + format + " format: " + filePath;
    }
}package HSEBank.finance.Core.patterns.commands;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.interfaces.IBankAccountService;
import lombok.Getter;

import java.util.UUID;

@Getter
public class UpdateAccountCommand extends BaseCommand {
    private final IBankAccountService accountService;
    private final UUID accountId;
    private final String newName;
    private final double newBalance;
    private final String oldName;
    private final double oldBalance;
    private BankAccount updatedAccount;

    public UpdateAccountCommand(IBankAccountService accountService, UUID accountId,
                                String newName, double newBalance) {
        super("Update bank account: " + accountId);
        this.accountService = accountService;
        this.accountId = accountId;
        this.newName = newName;
        this.newBalance = newBalance;

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è undo
        BankAccount oldAccount = accountService.getAccount(accountId);
        this.oldName = oldAccount.getName();
        this.oldBalance = oldAccount.getBalance();
    }

    @Override
    public void execute() {
        updatedAccount = accountService.updateAccount(accountId, newName, newBalance);
    }

    @Override
    public void undo() {
        accountService.updateAccount(accountId, oldName, oldBalance);
    }
}package HSEBank.finance.Core.patterns.commands;

import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.ICategoryService;
import lombok.Getter;

import java.util.UUID;

@Getter
public class UpdateCategoryCommand extends BaseCommand {
    private final ICategoryService categoryService;
    private final UUID categoryId;
    private final OperationType newType;
    private final String newName;
    private final OperationType oldType;
    private final String oldName;
    private Category updatedCategory;

    public UpdateCategoryCommand(ICategoryService categoryService, UUID categoryId,
                                 OperationType newType, String newName) {
        super("Update category: " + categoryId);
        this.categoryService = categoryService;
        this.categoryId = categoryId;
        this.newType = newType;
        this.newName = newName;

        Category oldCategory = categoryService.getCategory(categoryId);
        this.oldType = oldCategory.getOperationType();
        this.oldName = oldCategory.getName();
    }

    @Override
    public void execute() {
        updatedCategory = categoryService.updateCategory(categoryId, newType, newName);
    }

    @Override
    public void undo() {
        categoryService.updateCategory(categoryId, oldType, oldName);
    }
}package HSEBank.finance.Core.patterns.commands;

import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IOperationService;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.UUID;

@Getter
public class UpdateOperationCommand extends BaseCommand {
    private final IOperationService operationService;
    private final UUID operationId;
    private final OperationType newType;
    private final UUID newBankAccountId;
    private final double newAmount;
    private final LocalDateTime newDate;
    private final UUID newCategoryId;
    private final String newDescription;

    private final OperationType oldType;
    private final UUID oldBankAccountId;
    private final double oldAmount;
    private final LocalDateTime oldDate;
    private final UUID oldCategoryId;
    private final String oldDescription;

    private Operation updatedOperation;

    public UpdateOperationCommand(IOperationService operationService, UUID operationId,
                                  OperationType newType, UUID newBankAccountId, double newAmount,
                                  LocalDateTime newDate, UUID newCategoryId, String newDescription) {
        super("Update operation: " + operationId);
        this.operationService = operationService;
        this.operationId = operationId;
        this.newType = newType;
        this.newBankAccountId = newBankAccountId;
        this.newAmount = newAmount;
        this.newDate = newDate;
        this.newCategoryId = newCategoryId;
        this.newDescription = newDescription;

        Operation oldOperation = operationService.getOperation(operationId);
        this.oldType = oldOperation.getType();
        this.oldBankAccountId = oldOperation.getBankAccountId();
        this.oldAmount = oldOperation.getAmount();
        this.oldDate = oldOperation.getDate();
        this.oldCategoryId = oldOperation.getCategoryId();
        this.oldDescription = oldOperation.getDescription();
    }

    @Override
    public void execute() {
        updatedOperation = operationService.updateOperation(
                operationId, newType, newBankAccountId, newAmount, newDate, newCategoryId, newDescription
        );
    }

    @Override
    public void undo() {
        operationService.updateOperation(
                operationId, oldType, oldBankAccountId, oldAmount, oldDate, oldCategoryId, oldDescription
        );
    }
}package HSEBank.finance.Core.patterns.decorator;

import HSEBank.finance.Core.domain.interfaces.ICommand;

public class TimingDecorator implements ICommand {
    private final ICommand command;

    public TimingDecorator(ICommand command) {
        this.command = command;
    }

    @Override
    public void execute() {
        long startTime = System.currentTimeMillis();
        command.execute();
        long endTime = System.currentTimeMillis();
        System.out.println("Command '" + command.getDescription() +
                "' executed in " + (endTime - startTime) + "ms");
    }

    @Override
    public void undo() {
        command.undo();
    }

    @Override
    public String getDescription() {
        return command.getDescription();
    }
}package HSEBank.finance.Core.patterns.factory;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IFinancialFactory;
import java.time.LocalDateTime;
import java.util.UUID;
import org.springframework.stereotype.Component;

@Component
public class FinancialFactory implements IFinancialFactory {
    @Override
    public BankAccount createBankAccount(String name, double initialBalance) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Account name cannot be empty");
        }
        if (initialBalance < 0) {
            throw new IllegalArgumentException("Initial balance cannot be negative");
        }
        return new BankAccount(UUID.randomUUID(), name, initialBalance);
    }

    @Override
    public Category createCategory(OperationType type, String name) {
        if (name == null || name.trim().isEmpty()){
            throw new IllegalArgumentException("Category name cannot be empty");
        }
        return new Category(UUID.randomUUID(), type, name);
    }

    @Override
    public Operation createOperation(OperationType type, UUID bankAccountId, double amount, LocalDateTime date,
                                     UUID categoryId, String description) {
        return new Operation(UUID.randomUUID(), type, bankAccountId, amount, date, categoryId, description);
    }
}package HSEBank.finance.Core.patterns.template;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import org.springframework.stereotype.Component;

@Component
public class CsvDataImporter extends DataImporter {

    public CsvDataImporter(IRepository<BankAccount> accountRepository,
                           IRepository<Category> categoryRepository,
                           IRepository<Operation> operationRepository) {
        super(accountRepository, categoryRepository, operationRepository);
    }

    @Override
    protected ParsedData parseData(String content) {
        ParsedData result = new ParsedData();
        String[] lines = content.split("\n");

        for (int i = 1; i < lines.length; i++) { // Skip header
            String line = lines[i].trim();
            if (line.isEmpty()) continue;

            String[] fields = line.split(",");
            if (fields.length < 3) continue;

            String type = fields[0].trim();

            try {
                switch (type.toLowerCase()) {
                    case "account":
                        if (fields.length >= 4) {
                            BankAccount account = new BankAccount(
                                parseUUID(fields[1].trim()),
                                fields[2].trim(),
                                Double.parseDouble(fields[3].trim())
                            );
                            result.addAccount(account);
                        }
                        break;

                    case "category":
                        if (fields.length >= 4) {
                            Category category = new Category(
                                parseUUID(fields[1].trim()),
                                parseOperationType(fields[2].trim()),
                                fields[3].trim()
                            );
                            result.addCategory(category);
                        }
                        break;

                    case "operation":
                        if (fields.length >= 8) {
                            Operation operation = new Operation(
                                parseUUID(fields[1].trim()),
                                parseOperationType(fields[2].trim()),
                                parseUUID(fields[3].trim()),
                                Double.parseDouble(fields[4].trim()),
                                parseDateTime(fields[5].trim()),
                                parseUUID(fields[6].trim()),
                                fields[7].trim()
                            );
                            result.addOperation(operation);
                        }
                        break;
                }
            } catch (Exception e) {
                System.err.println("Error parsing CSV line: " + line + " - " + e.getMessage());
            }
        }

        return result;
    }

    @Override
    public boolean supportsFormat(String format) {
        return "csv".equalsIgnoreCase(format);
    }
}package HSEBank.finance.Core.patterns.template;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IRepository;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

public abstract class DataImporter {
    protected final IRepository<BankAccount> accountRepository;
    protected final IRepository<Category> categoryRepository;
    protected final IRepository<Operation> operationRepository;

    protected static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    public DataImporter(IRepository<BankAccount> accountRepository,
                        IRepository<Category> categoryRepository,
                        IRepository<Operation> operationRepository) {
        this.accountRepository = accountRepository;
        this.categoryRepository = categoryRepository;
        this.operationRepository = operationRepository;
    }

    public final String importData(String filePath) {
        try {
            String content = readFile(filePath);
            if (content == null || content.trim().isEmpty()) {
                return "File is empty or cannot be read: " + filePath;
            }

            ParsedData parsedData = parseData(content);
            return saveData(parsedData);
        } catch (Exception e) {
            return "Import failed for file " + filePath + ": " + e.getMessage();
        }
    }

    protected String readFile(String filePath) {
        try {
            Path path = Paths.get(filePath);
            if (!Files.exists(path)) {
                System.err.println("File not found: " + filePath);
                return null;
            }
            return Files.readString(path);
        } catch (IOException e) {
            System.err.println("Error reading file " + filePath + ": " + e.getMessage());
            return null;
        }
    }

    protected abstract ParsedData parseData(String content);

    protected String saveData(ParsedData data) {
        int accountsSaved = 0;
        int categoriesSaved = 0;
        int operationsSaved = 0;

        for (BankAccount account : data.getAccounts()) {
            if (!accountRepository.exists(account.getId())) {
                accountRepository.save(account);
                accountsSaved++;
            }
        }

        for (Category category : data.getCategories()) {
            if (!categoryRepository.exists(category.getId())) {
                categoryRepository.save(category);
                categoriesSaved++;
            }
        }

        for (Operation operation : data.getOperations()) {
            if (!operationRepository.exists(operation.getId())) {
                operationRepository.save(operation);
                operationsSaved++;
            }
        }

        return String.format("Imported: %d accounts, %d categories, %d operations",
            accountsSaved, categoriesSaved, operationsSaved);
    }

    protected UUID parseUUID(String uuidString) {
        return UUID.fromString(uuidString);
    }

    protected LocalDateTime parseDateTime(String dateString) {
        return LocalDateTime.parse(dateString, DATE_FORMATTER);
    }

    protected OperationType parseOperationType(String typeString) {
        return OperationType.valueOf(typeString.toUpperCase());
    }

    abstract public boolean supportsFormat(String format);
}package HSEBank.finance.Core.patterns.template;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.springframework.stereotype.Component;

@Component
public class JsonDataImporter extends DataImporter {

    public JsonDataImporter(IRepository<BankAccount> accountRepository,
                            IRepository<Category> categoryRepository,
                            IRepository<Operation> operationRepository) {
        super(accountRepository, categoryRepository, operationRepository);
    }

    @Override
    protected ParsedData parseData(String content) {
        try {
            ParsedData result = new ParsedData();

            // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ JSON —Å –ø–æ–º–æ—â—å—é —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π
            parseAccounts(content, result);
            parseCategories(content, result);
            parseOperations(content, result);

            return result;

        } catch (Exception e) {
            throw new RuntimeException("Error parsing JSON: " + e.getMessage(), e);
        }
    }

    private void parseAccounts(String content, ParsedData result) {
        // –ò—â–µ–º –±–ª–æ–∫ accounts
        Pattern accountsPattern = Pattern.compile("\"accounts\"\\s*:\\s*\\[([^\\]]+)\\]");
        Matcher accountsMatcher = accountsPattern.matcher(content);

        if (accountsMatcher.find()) {
            String accountsContent = accountsMatcher.group(1);
            // –ò—â–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã —Å—á–µ—Ç–æ–≤
            Pattern accountPattern = Pattern.compile("\\{([^}]+)\\}");
            Matcher accountMatcher = accountPattern.matcher(accountsContent);

            while (accountMatcher.find()) {
                String accountData = accountMatcher.group(1);
                try {
                    BankAccount account = parseAccount(accountData);
                    result.addAccount(account);
                } catch (Exception e) {
                    System.err.println("Error parsing account: " + e.getMessage());
                }
            }
        }
    }

    private BankAccount parseAccount(String accountData) {
        String id = extractField(accountData, "id");
        String name = extractField(accountData, "name");
        String balance = extractField(accountData, "balance");

        return new BankAccount(
            parseUUID(id),
            name.replace("\"", "").trim(),
            Double.parseDouble(balance)
        );
    }

    private void parseCategories(String content, ParsedData result) {
        Pattern categoriesPattern = Pattern.compile("\"categories\"\\s*:\\s*\\[([^\\]]+)\\]");
        Matcher categoriesMatcher = categoriesPattern.matcher(content);

        if (categoriesMatcher.find()) {
            String categoriesContent = categoriesMatcher.group(1);
            Pattern categoryPattern = Pattern.compile("\\{([^}]+)\\}");
            Matcher categoryMatcher = categoryPattern.matcher(categoriesContent);

            while (categoryMatcher.find()) {
                String categoryData = categoryMatcher.group(1);
                try {
                    Category category = parseCategory(categoryData);
                    result.addCategory(category);
                } catch (Exception e) {
                    System.err.println("Error parsing category: " + e.getMessage());
                }
            }
        }
    }

    private Category parseCategory(String categoryData) {
        String id = extractField(categoryData, "id");
        String type = extractField(categoryData, "type");
        String name = extractField(categoryData, "name");

        return new Category(
            parseUUID(id),
            parseOperationType(type.replace("\"", "").trim()),
            name.replace("\"", "").trim()
        );
    }

    private void parseOperations(String content, ParsedData result) {
        Pattern operationsPattern = Pattern.compile("\"operations\"\\s*:\\s*\\[([^\\]]+)\\]");
        Matcher operationsMatcher = operationsPattern.matcher(content);

        if (operationsMatcher.find()) {
            String operationsContent = operationsMatcher.group(1);
            Pattern operationPattern = Pattern.compile("\\{([^}]+)\\}");
            Matcher operationMatcher = operationPattern.matcher(operationsContent);

            while (operationMatcher.find()) {
                String operationData = operationMatcher.group(1);
                try {
                    Operation operation = parseOperation(operationData);
                    result.addOperation(operation);
                } catch (Exception e) {
                    System.err.println("Error parsing operation: " + e.getMessage());
                }
            }
        }
    }

    private Operation parseOperation(String operationData) {
        String id = extractField(operationData, "id");
        String type = extractField(operationData, "type");
        String bankAccountId = extractField(operationData, "bankAccountId");
        String amount = extractField(operationData, "amount");
        String date = extractField(operationData, "date");
        String categoryId = extractField(operationData, "categoryId");
        String description = extractOptionalField(operationData, "description");

        return new Operation(
            parseUUID(id),
            parseOperationType(type.replace("\"", "").trim()),
            parseUUID(bankAccountId),
            Double.parseDouble(amount),
            parseDateTime(date.replace("\"", "").trim()),
            parseUUID(categoryId),
            description != null ? description.replace("\"", "").trim() : null
        );
    }

    private String extractField(String data, String fieldName) {
        Pattern pattern = Pattern.compile("\"" + fieldName + "\"\\s*:\\s*\"?([^\",}]+)\"?");
        Matcher matcher = pattern.matcher(data);
        if (matcher.find()) {
            return matcher.group(1);
        }
        throw new RuntimeException("Field '" + fieldName + "' not found in: " + data);
    }

    private String extractOptionalField(String data, String fieldName) {
        Pattern pattern = Pattern.compile("\"" + fieldName + "\"\\s*:\\s*\"?([^\",}]+)\"?");
        Matcher matcher = pattern.matcher(data);
        return matcher.find() ? matcher.group(1) : null;
    }

    @Override
    public boolean supportsFormat(String format) {
        return "json".equalsIgnoreCase(format);
    }
}package HSEBank.finance.Core.patterns.template;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import java.util.ArrayList;
import java.util.List;
import lombok.Getter;

@Getter
public class ParsedData {
    private final List<BankAccount> accounts;
    private final List<Category> categories;
    private final List<Operation> operations;

    public ParsedData() {
        this.accounts = new ArrayList<>();
        this.categories = new ArrayList<>();
        this.operations = new ArrayList<>();
    }

    public void addAccount(BankAccount account) {
        this.accounts.add(account);
    }

    public void addCategory(Category category) {
        this.categories.add(category);
    }

    public void addOperation(Operation operation) {
        this.operations.add(operation);
    }
}package HSEBank.finance.Core.patterns.template;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.springframework.stereotype.Component;

@Component
public class YamlDataImporter extends DataImporter {

    public YamlDataImporter(IRepository<BankAccount> accountRepository,
                            IRepository<Category> categoryRepository,
                            IRepository<Operation> operationRepository) {
        super(accountRepository, categoryRepository, operationRepository);
    }

    @Override
    protected ParsedData parseData(String content) {
        try {
            ParsedData result = new ParsedData();

            // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ YAML
            parseYamlAccounts(content, result);
            parseYamlCategories(content, result);
            parseYamlOperations(content, result);

            return result;

        } catch (Exception e) {
            throw new RuntimeException("Error parsing YAML: " + e.getMessage(), e);
        }
    }

    private void parseYamlAccounts(String content, ParsedData result) {
        Pattern accountsSection = Pattern.compile("accounts:\\s*\\n(\\s+-.*?\\n)+");
        Matcher matcher = accountsSection.matcher(content);

        if (matcher.find()) {
            String accountsContent = matcher.group(0);
            Pattern accountPattern = Pattern.compile("-\\s*\\n\\s+id:\\s*(.+)\\n\\s+name:\\s*(.+)\\n\\s+balance:\\s*(.+)");
            Matcher accountMatcher = accountPattern.matcher(accountsContent);

            while (accountMatcher.find()) {
                try {
                    BankAccount account = new BankAccount(
                        parseUUID(accountMatcher.group(1).trim()),
                        accountMatcher.group(2).trim(),
                        Double.parseDouble(accountMatcher.group(3).trim())
                    );
                    result.addAccount(account);
                } catch (Exception e) {
                    System.err.println("Error parsing YAML account: " + e.getMessage());
                }
            }
        }
    }

    private void parseYamlCategories(String content, ParsedData result) {
        Pattern categoriesSection = Pattern.compile("categories:\\s*\\n(\\s+-.*?\\n)+");
        Matcher matcher = categoriesSection.matcher(content);

        if (matcher.find()) {
            String categoriesContent = matcher.group(0);
            Pattern categoryPattern = Pattern.compile("-\\s*\\n\\s+id:\\s*(.+)\\n\\s+type:\\s*(.+)\\n\\s+name:\\s*(.+)");
            Matcher categoryMatcher = categoryPattern.matcher(categoriesContent);

            while (categoryMatcher.find()) {
                try {
                    Category category = new Category(
                        parseUUID(categoryMatcher.group(1).trim()),
                        parseOperationType(categoryMatcher.group(2).trim()),
                        categoryMatcher.group(3).trim()
                    );
                    result.addCategory(category);
                } catch (Exception e) {
                    System.err.println("Error parsing YAML category: " + e.getMessage());
                }
            }
        }
    }

    private void parseYamlOperations(String content, ParsedData result) {
        Pattern operationsSection = Pattern.compile("operations:\\s*\\n(\\s+-.*?\\n)+");
        Matcher matcher = operationsSection.matcher(content);

        if (matcher.find()) {
            String operationsContent = matcher.group(0);
            // –ë–æ–ª–µ–µ –≥–∏–±–∫–∏–π –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π (description –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            Pattern operationPattern = Pattern.compile(
                "-\\s*\\n\\s+id:\\s*(.+)\\n\\s+type:\\s*(.+)\\n\\s+bankAccountId:\\s*(.+)\\n\\s+amount:\\s*(.+)\\n\\s+date:\\s*(.+)\\n\\s+categoryId:\\s*(.+)(\\n\\s+description:\\s*(.+))?"
            );
            Matcher operationMatcher = operationPattern.matcher(operationsContent);

            while (operationMatcher.find()) {
                try {
                    String description = operationMatcher.group(8); // description –º–æ–∂–µ—Ç –±—ã—Ç—å null
                    Operation operation = new Operation(
                        parseUUID(operationMatcher.group(1).trim()),
                        parseOperationType(operationMatcher.group(2).trim()),
                        parseUUID(operationMatcher.group(3).trim()),
                        Double.parseDouble(operationMatcher.group(4).trim()),
                        parseDateTime(operationMatcher.group(5).trim()),
                        parseUUID(operationMatcher.group(6).trim()),
                        description != null ? description.trim() : null
                    );
                    result.addOperation(operation);
                } catch (Exception e) {
                    System.err.println("Error parsing YAML operation: " + e.getMessage());
                }
            }
        }
    }

    @Override
    public boolean supportsFormat(String format) {
        return "yaml".equalsIgnoreCase(format) || "yml".equalsIgnoreCase(format);
    }
}package HSEBank.finance.Core.patterns.visitors;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.StructuredFinancialVisitor;

public class CsvExportVisitor implements StructuredFinancialVisitor {
    private final StringBuilder csvBuilder = new StringBuilder();
    private boolean headersWritten = false;

    @Override
    public void visit(BankAccount account) {
        if (!headersWritten) {
            csvBuilder.append("type,id,name,balance,operationType,bankAccountId,amount,date,categoryId,description\n");
            headersWritten = true;
        }

        csvBuilder.append("account,")
            .append(account.getId()).append(",")
            .append(escapeCsv(account.getName())).append(",")
            .append(account.getBalance()).append(",,,,\n");
    }

    @Override
    public void visit(Category category) {
        if (!headersWritten) {
            csvBuilder.append("type,id,name,balance,operationType,bankAccountId,amount,date,categoryId,description\n");
            headersWritten = true;
        }

        csvBuilder.append("category,")
            .append(category.getId()).append(",")
            .append(escapeCsv(category.getName())).append(",,,")
            .append(category.getOperationType()).append(",,,\n");
    }

    @Override
    public void visit(Operation operation) {
        if (!headersWritten) {
            csvBuilder.append("type,id,name,balance,operationType,bankAccountId,amount,date,categoryId,description\n");
            headersWritten = true;
        }

        csvBuilder.append("operation,")
            .append(operation.getId()).append(",,")
            .append(operation.getType()).append(",")
            .append(operation.getBankAccountId()).append(",")
            .append(operation.getAmount()).append(",")
            .append(operation.getDate()).append(",")
            .append(operation.getCategoryId()).append(",")
            .append(escapeCsv(operation.getDescription() != null ? operation.getDescription() : ""))
            .append("\n");
    }

    public String getResult() {
        return csvBuilder.toString();
    }

    @Override
    public void reset() {

    }

    public void startArray(String arrayName) {
    }

    public void endArray() {
    }

    private String escapeCsv(String text) {
        if (text == null) return "";
        if (text.contains(",") || text.contains("\"") || text.contains("\n")) {
            return "\"" + text.replace("\"", "\"\"") + "\"";
        }
        return text;
    }


}package HSEBank.finance.Core.patterns.visitors;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.StructuredFinancialVisitor;

public class JsonExportVisitor implements StructuredFinancialVisitor {
    private final StringBuilder jsonBuilder = new StringBuilder();
    private boolean firstElementInArray = true;
    private boolean arrayStarted = false;

    public JsonExportVisitor() {
        jsonBuilder.append("{\n");
    }

    @Override
    public String getResult() {
        if (arrayStarted) {
            jsonBuilder.append("\n  ]");
        }
        jsonBuilder.append("\n}");
        return jsonBuilder.toString();
    }

    @Override
    public void reset() {
        jsonBuilder.setLength(0);
        jsonBuilder.append("{\n");
        firstElementInArray = true;
        arrayStarted = false;
    }

    @Override
    public void startArray(String arrayName) {
        if (arrayStarted) {
            jsonBuilder.append(",\n");
        }
        jsonBuilder.append("  \"").append(arrayName).append("\": [");
        firstElementInArray = true;
        arrayStarted = true;
    }

    @Override
    public void endArray() {
        jsonBuilder.append("\n  ]");
        firstElementInArray = true;
        arrayStarted = false;
    }

    @Override
    public void visit(BankAccount account) {
        if (!firstElementInArray) {
            jsonBuilder.append(",");
        }
        jsonBuilder.append("\n    {\n")
                .append("      \"id\": \"").append(account.getId()).append("\",\n")
                .append("      \"name\": \"").append(escapeJson(account.getName())).append("\",\n")
                .append("      \"balance\": ").append(account.getBalance()).append("\n")
                .append("    }");
        firstElementInArray = false;
    }

    @Override
    public void visit(Category category) {
        if (!firstElementInArray) {
            jsonBuilder.append(",");
        }
        jsonBuilder.append("\n    {\n")
                .append("      \"id\": \"").append(category.getId()).append("\",\n")
                .append("      \"type\": \"").append(category.getOperationType()).append("\",\n")
                .append("      \"name\": \"").append(escapeJson(category.getName())).append("\"\n")
                .append("    }");
        firstElementInArray = false;
    }

    @Override
    public void visit(Operation operation) {
        if (!firstElementInArray) {
            jsonBuilder.append(",");
        }
        jsonBuilder.append("\n    {\n")
                .append("      \"id\": \"").append(operation.getId()).append("\",\n")
                .append("      \"type\": \"").append(operation.getType()).append("\",\n")
                .append("      \"bankAccountId\": \"").append(operation.getBankAccountId()).append("\",\n")
                .append("      \"amount\": ").append(operation.getAmount()).append(",\n")
                .append("      \"date\": \"").append(operation.getDate()).append("\",\n")
                .append("      \"categoryId\": \"").append(operation.getCategoryId()).append("\",\n")
                .append("      \"description\": \"")
                .append(operation.getDescription() != null ? escapeJson(operation.getDescription()) : "")
                .append("\"\n")
                .append("    }");
        firstElementInArray = false;
    }

    private String escapeJson(String text) {
        return text.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\b", "\\b")
                .replace("\f", "\\f")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}package HSEBank.finance.Core.patterns.visitors;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.StructuredFinancialVisitor;

public class YamlExportVisitor implements StructuredFinancialVisitor {
    private final StringBuilder yamlBuilder = new StringBuilder();
    private int indentLevel = 0;

    public YamlExportVisitor() {
        yamlBuilder.append("---\n");
    }

    @Override
    public void visit(BankAccount account) {
        yamlBuilder.append(getIndent()).append("-\n");
        indentLevel++;
        yamlBuilder.append(getIndent()).append("id: ").append(account.getId()).append("\n");
        yamlBuilder.append(getIndent()).append("name: ").append(account.getName()).append("\n");
        yamlBuilder.append(getIndent()).append("balance: ").append(account.getBalance()).append("\n");
        indentLevel--;
    }

    @Override
    public void visit(Category category) {
        yamlBuilder.append(getIndent()).append("-\n");
        indentLevel++;
        yamlBuilder.append(getIndent()).append("id: ").append(category.getId()).append("\n");
        yamlBuilder.append(getIndent()).append("type: ").append(category.getOperationType()).append("\n");
        yamlBuilder.append(getIndent()).append("name: ").append(category.getName()).append("\n");
        indentLevel--;
    }

    @Override
    public void visit(Operation operation) {
        yamlBuilder.append(getIndent()).append("-\n");
        indentLevel++;
        yamlBuilder.append(getIndent()).append("id: ").append(operation.getId()).append("\n");
        yamlBuilder.append(getIndent()).append("type: ").append(operation.getType()).append("\n");
        yamlBuilder.append(getIndent()).append("bankAccountId: ").append(operation.getBankAccountId()).append("\n");
        yamlBuilder.append(getIndent()).append("amount: ").append(operation.getAmount()).append("\n");
        yamlBuilder.append(getIndent()).append("date: ").append(operation.getDate()).append("\n");
        yamlBuilder.append(getIndent()).append("categoryId: ").append(operation.getCategoryId()).append("\n");
        if (operation.getDescription() != null && !operation.getDescription().isEmpty()) {
            yamlBuilder.append(getIndent()).append("description: ").append(operation.getDescription()).append("\n");
        }
        indentLevel--;
    }

    public String getResult() {
        return yamlBuilder.toString();
    }

    @Override
    public void reset() {

    }

    public void startArray(String arrayName) {
        yamlBuilder.append(getIndent()).append(arrayName).append(":\n");
        indentLevel++;
    }

    public void endArray() {
        indentLevel--;
    }

    private String getIndent() {
        return "  ".repeat(Math.max(0, indentLevel));
    }
}package HSEBank.finance.Core.services;

import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;

@Service
public class AnalyticsFacade {
    private final IRepository<Operation> operationRepository;
    private final IRepository<Category> categoryRepository;

    public AnalyticsFacade(IRepository<Operation> operationRepository,
                           IRepository<Category> categoryRepository) {
        this.operationRepository = operationRepository;
        this.categoryRepository = categoryRepository;
    }

    // a. –ü–æ–¥—Å—á–µ—Ç —Ä–∞–∑–Ω–∏—Ü—ã –¥–æ—Ö–æ–¥–æ–≤ –∏ —Ä–∞—Å—Ö–æ–¥–æ–≤ –∑–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥
    public double calculateBalanceDifference(LocalDateTime startDate, LocalDateTime endDate) {
        List<Operation> operations = getOperationsInPeriod(startDate, endDate);

        double totalIncome = operations.stream()
                .filter(op -> op.getType() == OperationType.INCOME)
                .mapToDouble(Operation::getAmount)
                .sum();

        double totalExpense = operations.stream()
                .filter(op -> op.getType() == OperationType.EXPENSE)
                .mapToDouble(Operation::getAmount)
                .sum();

        return totalIncome - totalExpense;
    }

    // b. –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –¥–æ—Ö–æ–¥–æ–≤ –∏ —Ä–∞—Å—Ö–æ–¥–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
    public Map<String, Double> groupIncomesByCategory(LocalDateTime startDate, LocalDateTime endDate) {
        return groupOperationsByCategory(OperationType.INCOME, startDate, endDate);
    }

    public Map<String, Double> groupExpensesByCategory(LocalDateTime startDate, LocalDateTime endDate) {
        return groupOperationsByCategory(OperationType.EXPENSE, startDate, endDate);
    }

    private Map<String, Double> groupOperationsByCategory(OperationType type, LocalDateTime startDate, LocalDateTime endDate) {
        return getOperationsInPeriod(startDate, endDate).stream()
                .filter(op -> op.getType() == type)
                .collect(Collectors.groupingBy(
                        op -> categoryRepository.findById(op.getCategoryId())
                                .map(Category::getName)
                                .orElse("Unknown"),
                        Collectors.summingDouble(Operation::getAmount)
                ));
    }

    // c. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
    public AnalyticsSummary getAnalyticsSummary(LocalDateTime startDate, LocalDateTime endDate) {
        List<Operation> operations = getOperationsInPeriod(startDate, endDate);

        double totalIncome = operations.stream()
                .filter(op -> op.getType() == OperationType.INCOME)
                .mapToDouble(Operation::getAmount)
                .sum();

        double totalExpense = operations.stream()
                .filter(op -> op.getType() == OperationType.EXPENSE)
                .mapToDouble(Operation::getAmount)
                .sum();

        long operationCount = operations.size();
        double averageIncome = operations.stream()
                .filter(op -> op.getType() == OperationType.INCOME)
                .mapToDouble(Operation::getAmount)
                .average()
                .orElse(0.0);

        double averageExpense = operations.stream()
                .filter(op -> op.getType() == OperationType.EXPENSE)
                .mapToDouble(Operation::getAmount)
                .average()
                .orElse(0.0);

        return new AnalyticsSummary(totalIncome, totalExpense, operationCount, averageIncome, averageExpense);
    }

    public double getTotalIncome(LocalDateTime startDate, LocalDateTime endDate) {
        return getOperationsInPeriod(startDate, endDate).stream()
                .filter(op -> op.getType() == OperationType.INCOME)
                .mapToDouble(Operation::getAmount)
                .sum();
    }

    public double getTotalExpense(LocalDateTime startDate, LocalDateTime endDate) {
        return getOperationsInPeriod(startDate, endDate).stream()
                .filter(op -> op.getType() == OperationType.EXPENSE)
                .mapToDouble(Operation::getAmount)
                .sum();
    }

    private List<Operation> getOperationsInPeriod(LocalDateTime startDate, LocalDateTime endDate) {
        return operationRepository.findAll().stream()
                .filter(op -> !op.getDate().isBefore(startDate) && !op.getDate().isAfter(endDate))
                .toList();
    }

    public static class AnalyticsSummary {
        public final double totalIncome;
        public final double totalExpense;
        public final long operationCount;
        public final double averageIncome;
        public final double averageExpense;

        public AnalyticsSummary(double totalIncome, double totalExpense, long operationCount,
                                double averageIncome, double averageExpense) {
            this.totalIncome = totalIncome;
            this.totalExpense = totalExpense;
            this.operationCount = operationCount;
            this.averageIncome = averageIncome;
            this.averageExpense = averageExpense;
        }
    }
}package HSEBank.finance.Core.services;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import org.springframework.stereotype.Service;

import java.util.UUID;

@Service
public class BalanceService {
    private final IRepository<BankAccount> accountRepository;
    private final IRepository<Operation> operationRepository;

    public BalanceService(IRepository<BankAccount> accountRepository, IRepository<Operation> operationRepository) {
        this.accountRepository = accountRepository;
        this.operationRepository = operationRepository;
    }

    public void applyOperation(Operation operation) {
        BankAccount account = accountRepository.findById(operation.getBankAccountId())
                .orElseThrow(() -> new IllegalArgumentException("Bank account not found"));

        if (operation.getType() == OperationType.INCOME) {
            account.deposit(operation.getAmount());
        } else {
            account.withdraw(operation.getAmount());
        }

        accountRepository.save(account);
    }

    public void revertOperation(Operation operation) {
        BankAccount account = accountRepository.findById(operation.getBankAccountId())
                .orElseThrow(() -> new IllegalArgumentException("Bank account not found"));

        // –û–±—Ä–∞—Ç–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è
        if (operation.getType() == OperationType.INCOME) {
            account.withdraw(operation.getAmount());
        } else {
            account.deposit(operation.getAmount());
        }

        accountRepository.save(account);
    }

    public double recalculateBalance(UUID accountId) {
        BankAccount account = accountRepository.findById(accountId)
                .orElseThrow(() -> new IllegalArgumentException("Bank account not found"));

        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –±–∞–ª–∞–Ω—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
        double calculatedBalance = operationRepository.findAll().stream()
                .filter(op -> op.getBankAccountId().equals(accountId))
                .mapToDouble(op -> op.getType() == OperationType.INCOME ? op.getAmount() : -op.getAmount())
                .sum();

        // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å —Å—á–µ—Ç–∞, –µ—Å–ª–∏ –æ–Ω –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è
        if (Math.abs(account.getBalance() - calculatedBalance) > 0.01) {
            account.update(account.getName(), calculatedBalance);
            accountRepository.save(account);
        }

        return calculatedBalance;
    }

    public BalanceRecalculationResult recalculateAllBalances() {
        var accounts = accountRepository.findAll();
        int correctedAccounts = 0;
        double totalCorrection = 0;

        for (BankAccount account : accounts) {
            double oldBalance = account.getBalance();
            double newBalance = recalculateBalance(account.getId());

            if (Math.abs(oldBalance - newBalance) > 0.01) {
                correctedAccounts++;
                totalCorrection += Math.abs(oldBalance - newBalance);
            }
        }

        return new BalanceRecalculationResult(accounts.size(), correctedAccounts, totalCorrection);
    }

    public static class BalanceRecalculationResult {
        public final int totalAccounts;
        public final int correctedAccounts;
        public final double totalCorrection;

        public BalanceRecalculationResult(int totalAccounts, int correctedAccounts, double totalCorrection) {
            this.totalAccounts = totalAccounts;
            this.correctedAccounts = correctedAccounts;
            this.totalCorrection = totalCorrection;
        }
    }
}package HSEBank.finance.Core.services;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.interfaces.IBankAccountService;
import HSEBank.finance.Core.domain.interfaces.IFinancialFactory;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Service
public class BankAccountFacade implements IBankAccountService {
    private final IFinancialFactory factory;
    private final IRepository<BankAccount> accountRepository;

    public BankAccountFacade(IFinancialFactory factory, IRepository<BankAccount> accountRepository){
        this.factory = factory;
        this.accountRepository = accountRepository;
    }

    @Override
    public BankAccount createAccount(String name, double initialBalance){
        BankAccount account = factory.createBankAccount(name, initialBalance);
        return accountRepository.save(account);
    }

    @Override
    public BankAccount getAccount(UUID id) {
        return accountRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Account not found with ID: " + id));
    }

    @Override
    public BankAccount updateAccount(UUID id, String name, double balance) {
        BankAccount account = getAccount(id);
        account.update(name, balance);
        return accountRepository.save(account);
    }

    @Override
    public void deleteAccount(UUID id) {
        if (!accountRepository.exists(id)) {
            throw new IllegalArgumentException("Account not found with ID: " + id);
        }
        accountRepository.delete(id);
    }

    @Override
    public List<BankAccount> getAllAccounts() {
        return accountRepository.findAll();
    }

    @Override
    public boolean accountExists(UUID id) {
        return accountRepository.exists(id);
    }
}package HSEBank.finance.Core.services;

import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.ICategoryService;
import HSEBank.finance.Core.domain.interfaces.IFinancialFactory;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Service
public class CategoryFacade implements ICategoryService {
    private final IFinancialFactory factory;
    private final IRepository<Category> categoryRepository;

    public CategoryFacade(IFinancialFactory factory, IRepository<Category> categoryRepository){
        this.factory = factory;
        this.categoryRepository = categoryRepository;
    }

    @Override
    public Category createCategory(OperationType type, String name){
        Category category = factory.createCategory(type, name);
        return categoryRepository.save(category);
    }

    @Override
    public Category getCategory(UUID id) {
        return categoryRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Category not found with ID: " + id));
    }

    @Override
    public Category updateCategory(UUID id, OperationType type, String name) {
        Category category = getCategory(id);
        category.update(type, name);
        return categoryRepository.save(category);
    }

    @Override
    public void deleteCategory(UUID id) {
        if (!categoryRepository.exists(id)) {
            throw new IllegalArgumentException("Category not found with ID: " + id);
        }
        categoryRepository.delete(id);
    }

    @Override
    public List<Category> getAllCategories() {
        return categoryRepository.findAll();
    }

    @Override
    public List<Category> getCategoriesByType(OperationType type) {
        return categoryRepository.findAll().stream()
                .filter(category -> category.getOperationType() == type)
                .toList();
    }

    @Override
    public boolean categoryExists(UUID id) {
        return categoryRepository.exists(id);
    }
}package HSEBank.finance.Core.services;

import HSEBank.finance.Core.patterns.template.DataImporter;
import HSEBank.finance.Core.patterns.template.CsvDataImporter;
import HSEBank.finance.Core.patterns.template.JsonDataImporter;
import HSEBank.finance.Core.patterns.template.YamlDataImporter;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class DataImportService {
    private final List<DataImporter> importers;

    // Spring –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–Ω–µ–¥—Ä–∏—Ç –≤—Å–µ –±–∏–Ω—ã, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–µ DataImporter
    public DataImportService(List<DataImporter> importers) {
        this.importers = importers;
    }

    public String importData(String format, String filePath) {
        DataImporter importer = findImporter(format);
        if (importer == null) {
            throw new IllegalArgumentException("Unsupported import format: " + format);
        }
        return importer.importData(filePath);
    }

    private DataImporter findImporter(String format) {
        return importers.stream()
                .filter(importer -> importer.supportsFormat(format))
                .findFirst()
                .orElse(null);
    }

    public boolean isFormatSupported(String format) {
        return findImporter(format) != null;
    }

    public List<String> getSupportedFormats() {
        return importers.stream()
                .map(importer -> {
                    if (importer instanceof JsonDataImporter) return "json";
                    if (importer instanceof CsvDataImporter) return "csv";
                    if (importer instanceof YamlDataImporter) return "yaml, yml";
                    return "unknown";
                })
                .collect(Collectors.toList());
    }
}package HSEBank.finance.Core.services;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.DataProvider;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Service
public class DefaultDataProvider implements DataProvider {
    private final IRepository<BankAccount> accountRepository;
    private final IRepository<Category> categoryRepository;
    private final IRepository<Operation> operationRepository;

    public DefaultDataProvider(IRepository<BankAccount> accountRepository,
                               IRepository<Category> categoryRepository,
                               IRepository<Operation> operationRepository) {
        this.accountRepository = accountRepository;
        this.categoryRepository = categoryRepository;
        this.operationRepository = operationRepository;
    }

    @Override
    public List<BankAccount> getAccounts(UUID accountId) {
        if (accountId != null) {
            return accountRepository.findById(accountId)
                    .map(List::of)
                    .orElse(List.of());
        }
        return accountRepository.findAll();
    }

    @Override
    public List<Category> getAllCategories() {
        return categoryRepository.findAll();
    }

    @Override
    public List<Operation> getOperations(UUID accountId) {
        if (accountId != null) {
            return operationRepository.findAll().stream()
                    .filter(op -> op.getBankAccountId().equals(accountId))
                    .toList();
        }
        return operationRepository.findAll();
    }
}// ExportService.java - —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
package HSEBank.finance.Core.services;

import HSEBank.finance.Core.domain.interfaces.DataProvider;
import HSEBank.finance.Core.domain.interfaces.StructuredFinancialVisitor;
import HSEBank.finance.Core.patterns.visitors.CsvExportVisitor;
import HSEBank.finance.Core.patterns.visitors.JsonExportVisitor;
import HSEBank.finance.Core.patterns.visitors.YamlExportVisitor;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Supplier;

@Service
public class ExportService {
    private final DataProvider dataProvider;
    private final Map<String, Supplier<StructuredFinancialVisitor>> visitorStrategies;

    public ExportService(DataProvider dataProvider) {
        this.dataProvider = dataProvider;
        this.visitorStrategies = new HashMap<>();
        initializeStrategies();
    }

    private void initializeStrategies() {
        visitorStrategies.put("json", JsonExportVisitor::new);
        visitorStrategies.put("csv", CsvExportVisitor::new);
        visitorStrategies.put("yaml", YamlExportVisitor::new);
    }

    public void registerFormat(String format, Supplier<StructuredFinancialVisitor> visitorSupplier) {
        visitorStrategies.put(format.toLowerCase(), visitorSupplier);
    }

    public void exportData(String format, String filePath, UUID accountId) {
        try {
            Supplier<StructuredFinancialVisitor> strategy = visitorStrategies.get(format.toLowerCase());
            if (strategy == null) {
                throw new IllegalArgumentException("Unsupported format: " + format);
            }

            StructuredFinancialVisitor visitor = strategy.get();
            String content = exportData(visitor, accountId);

            Path outputPath = Path.of(filePath);
            Files.createDirectories(outputPath.getParent());
            Files.writeString(outputPath, content);

            System.out.println("Data exported successfully to: " + filePath);

        } catch (IOException e) {
            throw new RuntimeException("Export failed: " + e.getMessage(), e);
        }
    }

    private String exportData(StructuredFinancialVisitor visitor, UUID accountId) {
        // –≠–∫—Å–ø–æ—Ä—Ç —Å—á–µ—Ç–æ–≤
        visitor.startArray("accounts");
        dataProvider.getAccounts(accountId).forEach(account -> account.accept(visitor));
        visitor.endArray();

        // –≠–∫—Å–ø–æ—Ä—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π
        visitor.startArray("categories");
        dataProvider.getAllCategories().forEach(category -> category.accept(visitor));
        visitor.endArray();

        // –≠–∫—Å–ø–æ—Ä—Ç –æ–ø–µ—Ä–∞—Ü–∏–π
        visitor.startArray("operations");
        dataProvider.getOperations(accountId).forEach(operation -> operation.accept(visitor));
        visitor.endArray();

        return visitor.getResult();
    }
}package HSEBank.finance.Core.services;

import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.enums.OperationType;
import HSEBank.finance.Core.domain.interfaces.IOperationService;
import HSEBank.finance.Core.domain.interfaces.IFinancialFactory;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Service
public class OperationFacade implements IOperationService {
    private final IFinancialFactory factory;
    private final IRepository<Operation> operationRepository;
    private final BalanceService balanceService;

    public OperationFacade(IFinancialFactory factory,
                           IRepository<Operation> operationRepository,
                           BalanceService balanceService){
        this.factory = factory;
        this.operationRepository = operationRepository;
        this.balanceService = balanceService;
    }

    @Override
    public Operation addOperation(OperationType type, UUID bankAccountId, double amount,
                                  LocalDateTime date, UUID categoryId, String description){
        Operation operation = factory.createOperation(type, bankAccountId, amount, date, categoryId, description);
        balanceService.applyOperation(operation);
        return operationRepository.save(operation);
    }

    @Override
    public Operation getOperation(UUID id) {
        return operationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Operation not found with ID: " + id));
    }

    @Override
    public Operation updateOperation(UUID id, OperationType type, UUID bankAccountId, double amount,
                                     LocalDateTime date, UUID categoryId, String description) {
        Operation operation = getOperation(id);

        balanceService.revertOperation(operation);

        operation.update(type, bankAccountId, amount, date, categoryId, description);

        balanceService.applyOperation(operation);

        return operationRepository.save(operation);
    }

    @Override
    public void deleteOperation(UUID id) {
        Operation operation = getOperation(id);
        balanceService.revertOperation(operation);
        operationRepository.delete(id);
    }

    @Override
    public List<Operation> getAllOperations() {
        return operationRepository.findAll();
    }

    @Override
    public List<Operation> getOperationsByAccount(UUID accountId) {
        return operationRepository.findAll().stream()
                .filter(op -> op.getBankAccountId().equals(accountId))
                .toList();
    }

    @Override
    public List<Operation> getOperationsInPeriod(LocalDateTime startDate, LocalDateTime endDate) {
        return operationRepository.findAll().stream()
                .filter(op -> !op.getDate().isBefore(startDate) && !op.getDate().isAfter(endDate))
                .toList();
    }
}package HSEBank.finance.Infrastructure.config;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import HSEBank.finance.Infrastructure.data.cache.RepositoryProxy;
import HSEBank.finance.Infrastructure.data.repositories.BankAccountRepository;
import HSEBank.finance.Infrastructure.data.repositories.CategoryRepository;
import HSEBank.finance.Infrastructure.data.repositories.OperationRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class RepositoryConfig {

    @Bean
    @Primary
    public IRepository<BankAccount> bankAccountRepository() {
        BankAccountRepository realRepository = new BankAccountRepository();
        return new RepositoryProxy<>(realRepository);
    }

    @Bean
    @Primary
    public IRepository<Category> categoryRepository() {
        CategoryRepository realRepository = new CategoryRepository();
        return new RepositoryProxy<>(realRepository);
    }

    @Bean
    @Primary
    public IRepository<Operation> operationRepository() {
        OperationRepository realRepository = new OperationRepository();
        return new RepositoryProxy<>(realRepository);
    }
}package HSEBank.finance.Infrastructure.data.cache;

import HSEBank.finance.Core.domain.interfaces.IEntity;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class RepositoryProxy<T extends IEntity> implements IRepository<T> {
    private final IRepository<T> realRepository;
    private final ConcurrentHashMap<UUID, T> cache = new ConcurrentHashMap<>();
    private int cacheHits = 0;
    private int cacheMisses = 0;
    private boolean allCached = false;

    public RepositoryProxy(IRepository<T> realRepository) {
        this.realRepository = realRepository;
        log.info("RepositoryProxy initialized for: {}", realRepository.getClass().getSimpleName());
    }

    @Override
    public T save(T entity) {
        log.debug("Saving entity: {}", entity.getId());
        T saved = realRepository.save(entity);
        cache.put(saved.getId(), saved);
        return saved;
    }

    @Override
    public Optional<T> findById(UUID id) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        T cached = cache.get(id);
        if (cached != null) {
            cacheHits++;
            log.debug("Cache HIT for ID: {}", id);
            return Optional.of(cached);
        }

        // –ö—ç—à –ø—Ä–æ–º–∞—Ö - –∏–¥–µ–º –≤ —Ä–µ–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
        cacheMisses++;
        log.debug("Cache MISS for ID: {}", id);
        Optional<T> result = realRepository.findById(id);

        // –ö—ç—à–∏—Ä—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        result.ifPresent(entity -> {
            cache.put(entity.getId(), entity);
            log.debug("Cached entity: {}", entity.getId());
        });

        return result;
    }

    @Override
    public List<T> findAll() {
        // –ï—Å–ª–∏ —É–∂–µ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–ª–∏ –≤—Å–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–∑ –∫—ç—à–∞
        if (allCached && !cache.isEmpty()) {
            cacheHits++;
            log.debug("Returning ALL from cache");
            return List.copyOf(cache.values());
        }

        // –ò–Ω–∞—á–µ –∑–∞–≥—Ä—É–∂–∞–µ–º –∏ –∫—ç—à–∏—Ä—É–µ–º
        cacheMisses++;
        log.debug("Loading ALL from real repository");
        List<T> allEntities = realRepository.findAll();

        // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
        cache.clear();
        allEntities.forEach(entity -> cache.put(entity.getId(), entity));
        allCached = true;

        log.debug("Cached {} entities", cache.size());
        return allEntities;
    }

    @Override
    public void delete(UUID id) {
        log.debug("Deleting entity: {}", id);
        realRepository.delete(id);
        cache.remove(id);
        // –ï—Å–ª–∏ —É–¥–∞–ª–∏–ª–∏ —ç–ª–µ–º–µ–Ω—Ç, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ allCached
        allCached = false;
    }

    @Override
    public boolean exists(UUID id) {
        // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        if (cache.containsKey(id)) {
            cacheHits++;
            return true;
        }

        cacheMisses++;
        return realRepository.exists(id);
    }

    // –ú–µ—Ç–æ–¥—ã –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∫—ç—à–∞
    public CacheStats getCacheStats() {
        return new CacheStats(
                cacheHits,
                cacheMisses,
                cache.size(),
                getCacheHitRatio()
        );
    }

    public double getCacheHitRatio() {
        int total = cacheHits + cacheMisses;
        return total > 0 ? (double) cacheHits / total : 0.0;
    }

    public void clearCache() {
        log.info("Clearing cache. Had {} entities", cache.size());
        cache.clear();
        cacheHits = 0;
        cacheMisses = 0;
        allCached = false;
    }

    public static class CacheStats {
        public final int hits;
        public final int misses;
        public final int size;
        public final double hitRatio;

        public CacheStats(int hits, int misses, int size, double hitRatio) {
            this.hits = hits;
            this.misses = misses;
            this.size = size;
            this.hitRatio = hitRatio;
        }
    }
}package HSEBank.finance.Infrastructure.data.repositories;

import HSEBank.finance.Core.domain.entities.BankAccount;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.stereotype.Repository;

@Repository
public class BankAccountRepository implements IRepository<BankAccount> {
    private final Map<UUID, BankAccount> storage = new ConcurrentHashMap<>();

    @Override
    public BankAccount save(BankAccount entity) {
        storage.put(entity.getId(), entity);
        return entity;
    }

    @Override
    public Optional<BankAccount> findById(UUID id) {
        return Optional.ofNullable(storage.get(id));
    }

    @Override
    public List<BankAccount> findAll() {
        return new ArrayList<>(storage.values());
    }

    @Override
    public void delete(UUID id) {
        storage.remove(id);
    }

    @Override
    public boolean exists(UUID id) {
        return storage.containsKey(id);
    }
}
package HSEBank.finance.Infrastructure.data.repositories;

import HSEBank.finance.Core.domain.entities.Category;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.stereotype.Repository;

@Repository
public class CategoryRepository implements IRepository<Category> {
    private final Map<UUID, Category> storage = new ConcurrentHashMap<>();

    @Override
    public Category save(Category entity) {
        storage.put(entity.getId(), entity);
        return entity;
    }

    @Override
    public Optional<Category> findById(UUID id) {
        return Optional.ofNullable(storage.get(id));
    }

    @Override
    public List<Category> findAll() {
        return new ArrayList<>(storage.values());
    }

    @Override
    public void delete(UUID id) {
        storage.remove(id);
    }

    @Override
    public boolean exists(UUID id) {
        return storage.containsKey(id);
    }
}
package HSEBank.finance.Infrastructure.data.repositories;

import HSEBank.finance.Core.domain.entities.Operation;
import HSEBank.finance.Core.domain.interfaces.IRepository;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.stereotype.Repository;

@Repository
public class OperationRepository implements IRepository<Operation> {
    private final Map<UUID, Operation> storage = new ConcurrentHashMap<>();

    @Override
    public Operation save(Operation entity) {
        storage.put(entity.getId(), entity);
        return entity;
    }

    @Override
    public Optional<Operation> findById(UUID id) {
        return Optional.ofNullable(storage.get(id));
    }

    @Override
    public List<Operation> findAll() {
        return new ArrayList<>(storage.values());
    }

    @Override
    public void delete(UUID id) {
        storage.remove(id);
    }

    @Override
    public boolean exists(UUID id) {
        return storage.containsKey(id);
    }
}
